Java源码（.java）经过编译（javac）后生成字节码文件（.class）。

.Class文件又被JVM中的解释器编译成机器码在不同的操作系统（Windows、Linux、Mac）上运行。

每种操作系统的解释器都是不同的，但基于解释器实现的虚拟机是相同的，这也是Java能够跨平台的原因。

在一个Java进程开始运行后，虚拟机就开始实例化。

JVM（Java Virtual Machine）是用于运行J**ava字节码**的**虚拟机**。包括：

- 一套字节码指令集
- 一组程序寄存器
- 一个虚拟机栈
- 一个虚拟机堆
- 一个方法区
- 一个垃圾回收器

JVM运行在操作系统之上，不与硬件设备直接交互。

Java程序的具体运行过程如下。

（1）**Java源文件**被编译器**编译**成**字节码文件**。

（2）JVM将字节码文件编译成相应操作系统的**机器码**。

（3）机器码调用相应操作系统的**本地方法库**执行相应的方法。

![img](C:\Users\hk199\Desktop\Notes\assets\JVM1.png)

Java虚拟机包括一个**类加载器子系统**（Class Loader SubSystem）、**运行时数据区**（Runtime Data Area）、**执行引擎**和**本地接口库**（Native InterfaceLibrary）。

本地接口库通过调用本地方法库（Native Method Library）与操作系统交互，

◎ **类加载器子系统（Class Loader）**

用于将编译好的**．Class**文件**加载到JVM中**。

类加载子系统是根据一个**类的全限定名**来加载该类的**二进制流**到**内存**中，在JVM 中将形成一份描述 Class 结构的**元信息对象**（方法区），通过该元信息对象可以获知 **Class 的结构信息**：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。

◎ **执行引擎**

包括**即时编译器**和**垃圾回收器**，即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象；

◎ **本地接口库**

用于调用操作系统的本地方法库完成具体的指令操作。

![img](C:\Users\hk199\Desktop\Notes\assets\JVM2.png)

◎ **运行时数据区**

用于存储**在JVM运行过程中产生的数据**，包括**程序计数器**、**方法区**、**本地方法区**、**虚拟机栈**和**虚拟机堆**.

经过编译生成的字节码文件（class文件），由 class loader（类加载子系统）加载后交给执行引擎执行。在执行引擎执行的过程中产生的数据会存储在一块**内存区域**。这块内存区域就是运行时区域。

**程序计数器：**用于**记录****当前线程**的**正在执行**的**字节码指令位置**。由于**虚拟机的多线程是切换线程并分配 cpu 执行时间的方式**实现的，不同线程的执行位置都需要记录下来，因此程序计数器是线程**私有的**

**虚拟机栈：**虚拟机栈是 Java 方法执行的内存结构，虚拟机会在每个 Java 方法执行时创建一个“**栈桢**”，用于**存储局部变量表**，**操作数栈**，**动态链接**，**方法出口**等信息。**当方法执行完毕时，该栈桢会从虚拟机栈中出栈。**其中局部变量表包含基本数据类型和对象引用。

在 Java 虚拟机规范中，对这个区域规定了**两种异常状态**：如**果线程请求的栈的深度大于虚拟机允许的深度**，将抛出 **StackOverFlowError** 异常（**栈溢出**），如果虚拟机栈可以**动态扩展**（现在大部分 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的 Java 虚拟机栈），如果扩展时**无法申请到足够的内存空间**，就会抛出 **OutOfmMemoryError** 异常（**没有足够的内存**）

**本地方法栈：**类似 Java 方法的执行有虚拟机栈，本地方法的执行则对应有本地方法栈

**方法区**：用于**存储**已被虚拟机加载的**类信息，常量，静态变量**，**即时编译器编译后的代码**等数据。**线程共享**

**Java 堆（Heap）**：堆的主要作用是**存放程序运行过程中创建的****对象实例**，因为要存放的对象实例有可能会极多，因此也是虚拟机内存管理中最大的一块。并且由于硬件条件有限，所以**需要不断回收**已“无用”的实例对象来腾出空间给新生成的实例对象；因此 **Java 的垃圾回收主要是针对堆进行回收的**（还有**方法区的常量池**），Java 堆很多时候也被称为**GC堆**（Garbage Collected Heap）。

[**JVM是如何工作的？**](https://frank-lam.github.io/fullstack-tutorial/#/JavaArchitecture/05-Java虚拟机?id=jvm是如何工作的？)

如上面的体系结构图所示，JVM 分为**三个主要的子系统**：

1. **类加载器子系统**
2. **运行时数据区**
3. **执行引擎**

**1、类加载器子系统**

Java的动态类加载功能是由类加载器子系统处理的。它负责**加载**、**链接**，并且在**运行时**首次引用类的时候**初始化类**，而不是在编译期间。

**1.1、加载**

这个组件负责**加载类**。BootStrap类加载器、Extension类加载器和Application类加载器是实现这个功能的三大类加载器。

1. **BootStrap类加载器** —— 负责从classpath加载类，如果没有类存在，将只加载rt.jar。这个加载器的**优先级最高**。
2. **Extension类加载器** —— 负责加载扩展文件夹（jre\lib）中的类。
3. **Application类加载器** —— 负责加载应用级classpath和环境变量指向的路径下的类。

上述类加载器在加载类文件时遵循委托层次结构算法。

**1.2、链接**

1. **校验** —— 字节码验证器将校验生成的字节码是否正确，如果校验失败，我们将获得校验错误信息。
2. **准备** —— 对于所有的静态变量，内存将被申请并分配默认值。
3. **解析** —— 所有标记的内存引用从方法区域被替换成的原始引用。

**1.3、初始化**

这是类加载的最后阶段，所有的静态变量都将被分配原值，静态代码块将被执行。

**运行时数据区**

运行时数据区被划分为五个主要部分：

- **方法区** —— 所有**类级数据**都将存储在这里，包括**静态变量**。每一个JVM只有一个方法区，并且它是一个**共享**资源。
- **堆区** —— **所有对象**及其**对应的实例变量**和**数组**等存储在此，每个JVM同样只有一个堆区。由于方法区和堆区是多线程内存共享，因此存储的数据是**非线程安全的**。
- **栈区** —— 每个线程都会创建一个单独的运行时栈。在每一次方法调用，都会在**栈内存中**创建一个**栈帧（Stack Frame）**。所有**局部变量**将在栈内存中创建。栈区是**线程安全**的，因为它不是一个共享资源。

  

​      **栈帧**可以被划分为三个实体：

**局部变量数组** —— 与方法中有多少局部变量有关，相应的值将存储在此处。**操作数栈** —— 如果任何的中间操作需要被执行，操作数栈将作为运行时工作区来执行操作。 **帧数据** —— 与方法相对应的所有符号存储在此。在任何异常情况下，catch块的信息被保留在帧数据中。

- **PC寄存器** —— 每一个线程都有单独的PC寄存器，一旦执行指令，PC寄存器将被下一条指令更新，保存当前执行指令的地址。
- **本地方法栈** —— 本地方法栈保存本地方法信息，每一个线程都会创建一个单独的本地方栈。

**3、执行引擎**

分配到运行时数据区的字节码将被执行引擎执行。**执行引擎读取字节码并逐一执行。**

- **解释器** —— 解释器能更加快速地解释字节码，但是执行缓慢。解释器的缺点是当多次调用一个方法时，每次都要重新解释。
- **JIT编译器** —— JIT编译器弥补了解释器的不足。执行引擎使用解释器来转换字节码，当它发现重复的代码时，它将使用JIT编译器来编译整个字节码并转换为本地代码。本地代码将直接被重复的方法所调用，从而提高系统性能。
- **中间代码生成器** —— 生成中间代码。
- **代码优化器** —— 负责优化上述生成的中间代码。
- **目标代码生成器** —— 负责生成机器码或者本地代码。
- **分析器** —— 一个特殊的组件，负责查找热点代码，比如一个方法是否被调用多次。
- **垃圾回收器** —— 回收并删除未引用的对象。可以通过**调用System.gc()**来触发垃圾回收，但不能保证它执行。JVM的垃圾回收是回收被创建的对象。

**Java本地接口（JNI）**：JNI与本地方法库交互，并为执行引擎提供本地方法库。

**本地方法库**（Native Method Libraries）：它是执行引擎所需的本地库集合。