# JVM

## 1、基础概念

JVM（Java Virtual Machine），Java虚拟机，用于运行J**Java字节码**。

Java源码（.java）经过**编译**（javac）后生成**字节码文件（.class）**。

.class文件又被JVM中的**解释器**编译成机器码在不同的操作系统（Windows、Linux、Mac）上运行。

（1）**Java源文件**被编译器**编译**成**字节码文件**。

（2）JVM将字节码文件编译成相应操作系统的**机器码**。

（3）机器码调用相应操作系统的**本地方法库**执行相应的方法。

每种操作系统的解释器都是不同的，但基于解释器实现的虚拟机是相同的，这也是Java能够跨平台的原因。

JVM本质是软件，运行在操作系统上，不与硬件直接交互。

在一个Java进程开始运行后，虚拟机就开始实例化，多个程序启动就会存在多个虚拟机实例  。



**Hotspot JVM** 中的 Java 线程与原生操作系统线程有直接的映射关系。

当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。

Java 线程结束，原生线程随之被回收。

操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源  。





## 2、JVM体系结构

Java虚拟机包括一个**类加载器子系统**（Class Loader SubSystem）、**运行时数据区**（Runtime Data Area）、**执行引擎**和**本地接口库**（Native InterfaceLibrary）。



![](https://img-blog.csdnimg.cn/2020101809191097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDU5MzQz,size_16,color_FFFFFF,t_70#pic_center)



![](https://img-blog.csdnimg.cn/20201018092334555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDU5MzQz,size_16,color_FFFFFF,t_70#pic_center)





本地接口库通过调用本地方法库（Native Method Library）与操作系统交互。

◎ **类加载器子系统（Class Loader）**

用于将编译好的**．Class**文件**加载到JVM中**。

类加载子系统是根据一个**类的全限定名**来加载该类的**二进制流**到**内存**中，在JVM 中将形成一份描述 Class 结构的**元信息对象**（方法区），通过该元信息对象可以获知 **Class 的结构信息**：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。

![](https://img-blog.csdnimg.cn/20201018092813395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDU5MzQz,size_16,color_FFFFFF,t_70#pic_center)





![](![双亲委派](https://img-blog.csdnimg.cn/20201018092813395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDU5MzQz,size_16,color_FFFFFF,t_70#pic_center))



![](https://img-blog.csdnimg.cn/20201018092723707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDU5MzQz,size_16,color_FFFFFF,t_70#pic_center)











◎ **执行引擎**

包括**即时编译器**和**垃圾回收器**，即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象；

◎ **本地接口库**

用于调用操作系统的本地方法库完成具体的指令操作。

!(C:\Users\hk199\Desktop\Notes\assets\JVM2.png)

◎ **运行时数据区**

用于存储**在JVM运行过程中产生的数据**，包括**程序计数器**、**方法区**、**本地方法区**、**虚拟机栈**和**虚拟机堆**.

经过编译生成的字节码文件（class文件），由 class loader（类加载子系统）加载后交给执行引擎执行。在执行引擎执行的过程中产生的数据会存储在一块**内存区域**。这块内存区域就是运行时区域。

**程序计数器：**用于**记录****当前线程**的**正在执行**的**字节码指令位置**。由于**虚拟机的多线程是切换线程并分配 cpu 执行时间的方式**实现的，不同线程的执行位置都需要记录下来，因此程序计数器是线程**私有的**

**虚拟机栈：**虚拟机栈是 Java 方法执行的内存结构，虚拟机会在每个 Java 方法执行时创建一个“**栈桢**”，用于**存储局部变量表**，**操作数栈**，**动态链接**，**方法出口**等信息。**当方法执行完毕时，该栈桢会从虚拟机栈中出栈。**其中局部变量表包含基本数据类型和对象引用。

在 Java 虚拟机规范中，对这个区域规定了**两种异常状态**：如**果线程请求的栈的深度大于虚拟机允许的深度**，将抛出 **StackOverFlowError** 异常（**栈溢出**），如果虚拟机栈可以**动态扩展**（现在大部分 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的 Java 虚拟机栈），如果扩展时**无法申请到足够的内存空间**，就会抛出 **OutOfmMemoryError** 异常（**没有足够的内存**）

**本地方法栈：**类似 Java 方法的执行有虚拟机栈，本地方法的执行则对应有本地方法栈

**方法区**：用于**存储**已被虚拟机加载的**类信息，常量，静态变量**，**即时编译器编译后的代码**等数据。**线程共享**

**Java 堆（Heap）**：堆的主要作用是**存放程序运行过程中创建的****对象实例**，因为要存放的对象实例有可能会极多，因此也是虚拟机内存管理中最大的一块。并且由于硬件条件有限，所以**需要不断回收**已“无用”的实例对象来腾出空间给新生成的实例对象；因此 **Java 的垃圾回收主要是针对堆进行回收的**（还有**方法区的常量池**），Java 堆很多时候也被称为**GC堆**（Garbage Collected Heap）。

[**JVM是如何工作的？**](https://frank-lam.github.io/fullstack-tutorial/#/JavaArchitecture/05-Java虚拟机?id=jvm是如何工作的？)

如上面的体系结构图所示，JVM 分为**三个主要的子系统**：

1. **类加载器子系统**
2. **运行时数据区**
3. **执行引擎**

**1、类加载器子系统**

Java的动态类加载功能是由类加载器子系统处理的。它负责**加载**、**链接**，并且在**运行时**首次引用类的时候**初始化类**，而不是在编译期间。

**1.1、加载**

这个组件负责**加载类**。BootStrap类加载器、Extension类加载器和Application类加载器是实现这个功能的三大类加载器。

1. **BootStrap类加载器** —— 负责从classpath加载类，如果没有类存在，将只加载rt.jar。这个加载器的**优先级最高**。
2. **Extension类加载器** —— 负责加载扩展文件夹（jre\lib）中的类。
3. **Application类加载器** —— 负责加载应用级classpath和环境变量指向的路径下的类。

上述类加载器在加载类文件时遵循委托层次结构算法。

**1.2、链接**

1. **校验** —— 字节码验证器将校验生成的字节码是否正确，如果校验失败，我们将获得校验错误信息。
2. **准备** —— 对于所有的静态变量，内存将被申请并分配默认值。
3. **解析** —— 所有标记的内存引用从方法区域被替换成的原始引用。

**1.3、初始化**

这是类加载的最后阶段，所有的静态变量都将被分配原值，静态代码块将被执行。

**运行时数据区**

运行时数据区被划分为五个主要部分：

- **方法区** —— 所有**类级数据**都将存储在这里，包括**静态变量**。每一个JVM只有一个方法区，并且它是一个**共享**资源。
- **堆区** —— **所有对象**及其**对应的实例变量**和**数组**等存储在此，每个JVM同样只有一个堆区。由于方法区和堆区是多线程内存共享，因此存储的数据是**非线程安全的**。
- **栈区** —— 每个线程都会创建一个单独的运行时栈。在每一次方法调用，都会在**栈内存中**创建一个**栈帧（Stack Frame）**。所有**局部变量**将在栈内存中创建。栈区是**线程安全**的，因为它不是一个共享资源。

  

​      **栈帧**可以被划分为三个实体：

**局部变量数组** —— 与方法中有多少局部变量有关，相应的值将存储在此处。**操作数栈** —— 如果任何的中间操作需要被执行，操作数栈将作为运行时工作区来执行操作。 **帧数据** —— 与方法相对应的所有符号存储在此。在任何异常情况下，catch块的信息被保留在帧数据中。

- **PC寄存器** —— 每一个线程都有单独的PC寄存器，一旦执行指令，PC寄存器将被下一条指令更新，保存当前执行指令的地址。
- **本地方法栈** —— 本地方法栈保存本地方法信息，每一个线程都会创建一个单独的本地方栈。

**3、执行引擎**

分配到运行时数据区的字节码将被执行引擎执行。**执行引擎读取字节码并逐一执行。**

- **解释器** —— 解释器能更加快速地解释字节码，但是执行缓慢。解释器的缺点是当多次调用一个方法时，每次都要重新解释。
- **JIT编译器** —— JIT编译器弥补了解释器的不足。执行引擎使用解释器来转换字节码，当它发现重复的代码时，它将使用JIT编译器来编译整个字节码并转换为本地代码。本地代码将直接被重复的方法所调用，从而提高系统性能。
- **中间代码生成器** —— 生成中间代码。
- **代码优化器** —— 负责优化上述生成的中间代码。
- **目标代码生成器** —— 负责生成机器码或者本地代码。
- **分析器** —— 一个特殊的组件，负责查找热点代码，比如一个方法是否被调用多次。
- **垃圾回收器** —— 回收并删除未引用的对象。可以通过**调用System.gc()**来触发垃圾回收，但不能保证它执行。JVM的垃圾回收是回收被创建的对象。

**Java本地接口（JNI）**：JNI与本地方法库交互，并为执行引擎提供本地方法库。

**本地方法库**（Native Method Libraries）：它是执行引擎所需的本地库集合。